Many scRNA-seq analysis procedures involve comparing cells based on their expression values across multiple genes. To elaborate this statement, let's consider a bunch of cells and each cells have three genes namely, $A$, $B$ and $C$. Now, if we consider three axes (x-y-z) to be the expression level for $A$, $B$ and $C$ respectively, we can plot each cell on this co-ordinate system based on the corresponding value (expression level) on these axes. And we can literally see how the cells are clustering together. In such an ideal scenario we can just visually observe on the co-ordinate system itself what different groups of cells are being formed and we can move on with our life. But, in reality cells lie a in multi-dimensional system (because a cell is described by more than three genes, always.) and we can't put all the genes on a corresponding axis (remember we can visualize only three axes: for us humans) to make the visual cluster of cells. But lucky for us, Mathematics is not constrained by such ability to visualize high dimensional space. Unlike us, mathematics can visualize, observe, and digest the idea of cells residing in high dimensonal space without getting baffled. And in doing so it can create distinct cell polulations based on similarity/dissimilarity among cells. Dimension reduction, as the name suggest, aims to reduce the number of separate dimensions in the data. This is possible because different genes are correlated if they are affected by the same biological process. Thus, we do not need to store separate information for individual genes, but can instead compress multiple features into a single dimension, e.g., an “eigengene”. 

We will use the Zeisel et al. (2015) dataset to demonstrate the applications of various dimensionality reduction methods.

```r
#--- loading ---#
library(scRNAseq)
sce.zeisel <- ZeiselBrainData()

library(scater)
sce.zeisel <- aggregateAcrossFeatures(sce.zeisel, 
    id=sub("_loc[0-9]+$", "", rownames(sce.zeisel)))

#--- gene-annotation ---#
library(org.Mm.eg.db)
rowData(sce.zeisel)$Ensembl <- mapIds(org.Mm.eg.db, 
    keys=rownames(sce.zeisel), keytype="SYMBOL", column="ENSEMBL")
 
 #--- quality-control ---#
stats <- perCellQCMetrics(sce.zeisel, subsets=list(
    Mt=rowData(sce.zeisel)$featureType=="mito"))
qc <- quickPerCellQC(stats, percent_subsets=c("altexps_ERCC_percent", 
    "subsets_Mt_percent"))
sce.zeisel <- sce.zeisel[,!qc$discard]

#--- normalization ---#
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.zeisel)
sce.zeisel <- computeSumFactors(sce.zeisel, cluster=clusters) 
sce.zeisel <- logNormCounts(sce.zeisel)

#--- variance-modelling ---#
dec.zeisel <- modelGeneVarWithSpikes(sce.zeisel, "ERCC")
top.hvgs <- getTopHVGs(dec.zeisel, prop=0.1)
```

```r
> sce.zeisel
class: SingleCellExperiment 
dim: 19839 2816 
metadata(0):
assays(2): counts logcounts
rownames(19839): 0610005C13Rik 0610007N19Rik ... Zzef1 Zzz3
rowData names(2): featureType Ensembl
colnames(2816): 1772071015_C02 1772071017_G12 ... 1772063068_D01
  1772066098_A12
colData names(11): tissue group # ... level2class sizeFactor
reducedDimNames(0):
mainExpName: endogenous
altExpNames(2): ERCC repeat
```

### principle component analysis

Principal components analysis (PCA) discovers axes in high-dimensional space that capture the largest amount of variation (in this case the largest amount of variation exibited among the cells). This is best understood by imagining each axis as a line. Say we draw a line anywhere, and we move each cell in our data set onto the closest position on the line (something like seen in the figure below; adopted from Bill connolley). The variance captured by this axis is defined as the variance in the positions of cells along that line. In PCA, the first axis (or “principal component”, PC) is chosen such that it maximizes this variance. The next PC is chosen such that it is orthogonal to the first and captures the greatest remaining amount of variation, and so on. 

![PCA](https://user-images.githubusercontent.com/85447250/211915684-474a4fcb-efcd-4298-805f-2ccdb481a483.gif)

```r
top.zeisel <- getTopHVGs(dec.zeisel, n=2000)
set.seed(100)
sce.zeisel <- fixedPCA(sce.zeisel, subset.row=top.zeisel)

> dim(reducedDim(sce.zeisel))
[1] 2816   50

```

**explanation**
`top.zeisel` is character vector of length $2000$. It contains all the top $2000$ genes with highest biological component. `fixedPCA` will perform PCA analysis on a set of rows (genes) of an `SCE` as specified by `subset.row` option (	
A logical, character or integer vector specifying the rows of `SCE` to use in the PCA). It will return a `SCE` with PCA stored in `reducedDim()` of `SCE`. dim(reducedDim(sce.zeisel)) produces a dataFrame where PCs (50) are columns and cells (2816) constitute rows.
**end of explanation**

### Visualizing the PCs ###

We can visualize the PCs corresponding to the largest variations by ploting PC1 vs PC2. We can use `plotReducedDim()` from **scater**. 

```r
plotReducedDim(sce.zeisel, dimred="PCA", colour_by="level1class")

> colnames(colData(sce.zeisel))
 [1] "tissue"         "group #"        "total mRNA mol" "well"          
 [5] "sex"            "age"            "diameter"       "cell_id"       
 [9] `"level1class"`    "level2class"    "sizeFactor" 
 ```
 













