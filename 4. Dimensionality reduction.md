Many scRNA-seq analysis procedures involve comparing cells based on their expression values across multiple genes. To elaborate this statement, let's consider a bunch of cells and each cells have three genes namely, $A$, $B$ and $C$. Now, if we consider three axes (x-y-z) to be the expression level for $A$, $B$ and $C$ respectively, we can plot each cell on this co-ordinate system based on the corresponding value (expression level) on these axes. And we can literally see how the cells are clustering together. In such an ideal scenario we can just visually observe on the co-ordinate system itself what different groups of cells are being formed and we can move on with our life. But, in reality cells lie a in multi-dimensional system (because a cell is described by more than three genes, always.) and we can't put all the genes on a corresponding axis (remember we can visualize only three axes: for us humans) to make the visual cluster of cells. But lucky for us, Mathematics is not constrained by such ability to visualize high dimensional space. Unlike us, mathematics can visualize, observe, and digest the idea of cells residing in high dimensonal space without getting baffled. And in doing so it can create distinct cell polulations based on similarity/dissimilarity among cells. Dimension reduction, as the name suggest, aims to reduce the number of separate dimensions in the data. This is possible because different genes are correlated if they are affected by the same biological process. Thus, we do not need to store separate information for individual genes, but can instead compress multiple features into a single dimension, e.g., an “eigengene”. 

We will use the Zeisel et al. (2015) dataset to demonstrate the applications of various dimensionality reduction methods.

```r
#--- loading ---#
library(scRNAseq)
sce.zeisel <- ZeiselBrainData()

library(scater)
sce.zeisel <- aggregateAcrossFeatures(sce.zeisel, 
    id=sub("_loc[0-9]+$", "", rownames(sce.zeisel)))

#--- gene-annotation ---#
library(org.Mm.eg.db)
rowData(sce.zeisel)$Ensembl <- mapIds(org.Mm.eg.db, 
    keys=rownames(sce.zeisel), keytype="SYMBOL", column="ENSEMBL")
 
 #--- quality-control ---#
stats <- perCellQCMetrics(sce.zeisel, subsets=list(
    Mt=rowData(sce.zeisel)$featureType=="mito"))
qc <- quickPerCellQC(stats, percent_subsets=c("altexps_ERCC_percent", 
    "subsets_Mt_percent"))
sce.zeisel <- sce.zeisel[,!qc$discard]

#--- normalization ---#
library(scran)
set.seed(1000)
clusters <- quickCluster(sce.zeisel)
sce.zeisel <- computeSumFactors(sce.zeisel, cluster=clusters) 
sce.zeisel <- logNormCounts(sce.zeisel)

#--- variance-modelling ---#
dec.zeisel <- modelGeneVarWithSpikes(sce.zeisel, "ERCC")
top.hvgs <- getTopHVGs(dec.zeisel, prop=0.1)
```


