### Assigning cell label from reference data

+ Using existing reference

We will use method from `SingleR`. This method assign label to an unknown cell (our test data) from a reference samples based on the spearman rank correlation between the marker genes of our unknown cell and the reference sample. But first we need to get out test data and a reference sample. We will agin use 10x PBMC as test data and use `celldex` (a library pacage which contains curated data sets) as a source of reference sample.

```r

# Loading the data

raw.path <- getTestFile("tenx-2.1.0-pbmc4k/1.0.0/raw.tar.gz")
out.path <- file.path(tempdir(), "pbmc4k")
untar(raw.path, exdir=out.path)

fname <- file.path(out.path, "raw_gene_bc_matrices/GRCh38")
sce.pbmc <- read10xCounts(fname, col.names=TRUE)
colnames(rowData(sce.pbmc))

# Gene annotation

rownames(sce.pbmc) <- uniquifyFeatureNames(rowData(sce.pbmc)$ID, 
                                           rowData(sce.pbmc)$Symbol)
location <- mapIds(EnsDb.Hsapiens.v86, keys = rowData(sce.pbmc)$ID,
                   keytype = "GENEID", column = "SEQNAME")

# Cell detection
set.seed(1000)
e.out <- emptyDrops(counts(sce.pbmc))
sce.pbmc <- sce.pbmc[,which(e.out$FDR <= 0.001)]

# Quality control
stats <- perCellQCMetrics(sce.pbmc, subsets=list(Mito=which(location=="MT")))
high.mito <- isOutlier(stats$subsets_Mito_percent, type="higher")
sce.pbmc <- sce.pbmc[,!high.mito]

# Normalization 

set.seed(100)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster=clusters)
sce.pbmc <- logNormCounts(sce.pbmc)

# Variance modeling

set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
top.pbmc <- getTopHVGs(dec.pbmc, prop=0.1)

# Dimensinality reduction 
g <- buildSNNGraph(sce.pbmc, k=10, use.dimred = 'PCA')
clust <- igraph::cluster_walktrap(g)$membership
colLabels(sce.pbmc) <- factor(clust)

> sce.pbmc
class: SingleCellExperiment 
dim: 33694 3994 
metadata(1): Samples
assays(2): counts logcounts
rownames(33694): RP11-34P13.3 FAM138A ... AC213203.1 FAM231B
rowData names(2): ID Symbol
colnames(3994): AAACCTGAGAAGGCCT-1 AAACCTGAGACAGACC-1 ...
  TTTGTCAGTTAAGACA-1 TTTGTCATCCCAAGAT-1
colData names(4): Sample Barcode sizeFactor label
reducedDimNames(3): PCA TSNE UMAP
mainExpName: NULL
altExpNames(0):
```

Now we will create a reference with BlueprintEncodeData() function from `celldex` package.
This function provides normalized expression values for 259 bulk RNA-seq samples generated by Blueprint and ENCODE projects (Martens and Stunnenberg, 2013; The ENCODE Consortium, 2012). BlueprintEncodeData() function will return a 'SummarizedExperiment' object with a "logcounts" assay containing the log-normalized expression values, along with cell type labels in the colData. Blueprint Epigenomics contains 144 RNA-seq pure immune samples annotated to 28 cell types. ENCODE contains 115 RNA-seq pure stroma and immune samples annotated to 17 cell types. All together, this reference contains 259 samples with 43 cell types ("label.fine"), manually aggregated into 25 broad classes (see below tabulated summary for "label.main"). 

```r
ref <- BlueprintEncodeData()

> ref
class: SummarizedExperiment 
dim: 19859 259 
metadata(0):
assays(1): logcounts
rownames(19859): TSPAN6 TNMD ... LINC00550 GIMAP1-GIMAP5
rowData names(0):
colnames(259): mature.neutrophil
  CD14.positive..CD16.negative.classical.monocyte ...
  epithelial.cell.of.umbilical.artery.1
  dermis.lymphatic.vessel.endothelial.cell.1
colData names(3): label.main label.fine label.ont

> table(colData(ref)$label.main)

       Adipocytes        Astrocytes           B-cells      CD4+ T-cells 
                9                 2                 8                14 
     CD8+ T-cells      Chondrocytes                DC Endothelial cells 
                5                 2                 1                26 
      Eosinophils  Epithelial cells      Erythrocytes       Fibroblasts 
                1                18                 7                20 
              HSC     Keratinocytes       Macrophages       Melanocytes 
               38                 2                25                 4 
  Mesangial cells         Monocytes          Myocytes           Neurons 
                2                16                 4                 4 
      Neutrophils          NK cells         Pericytes   Skeletal muscle 
               23                 3                 2                 7 
    Smooth muscle 
               16 
  
  > head(factor(colData(ref)$label.main))
[1] Neutrophils Monocytes   Neutrophils HSC         Neutrophils Monocytes  
25 Levels: Adipocytes Astrocytes B-cells CD4+ T-cells CD8+ T-cells ... Smooth muscle
```

Now we are ready to use `SingleR()` function to annotate each of our PBMCs with the main cell type labels from the Blueprint/ENCODE reference. This returns a `DataFrame` where each row corresponds to a cell in the test dataset and contains its label assignments (see "label" column in the pred DataFrame). 

```r
pred <- SingleR(test=sce.pbmc, ref=ref, labels=ref$label.main)

head(pred)
DataFrame with 6 rows and 5 columns
                                           scores first.labels       tuning.scores
                                         <matrix>  <character>         <DataFrame>
AAACCTGAGAAGGCCT-1 0.251873:0.118890:0.287805:...    Monocytes 0.413717:0.00491616
AAACCTGAGACAGACC-1 0.280080:0.133100:0.334590:...    Monocytes 0.469530:0.40291032
AAACCTGAGGCATGGT-1 0.211503:0.153752:0.345878:... CD4+ T-cells 0.180486:0.06419868
AAACCTGCAAGGTTCT-1 0.218346:0.155343:0.367597:... CD8+ T-cells 0.307063:0.19412309
AAACCTGCAGGCGATA-1 0.323697:0.182205:0.483679:...    Monocytes 0.558153:0.50413520
AAACCTGCATGAAGTA-1 0.312739:0.166972:0.461094:...    Monocytes 0.531659:0.46923231
                         labels pruned.labels
                    <character>   <character>
AAACCTGAGAAGGCCT-1    Monocytes     Monocytes
AAACCTGAGACAGACC-1    Monocytes     Monocytes
AAACCTGAGGCATGGT-1 CD4+ T-cells  CD4+ T-cells
AAACCTGCAAGGTTCT-1 CD8+ T-cells  CD8+ T-cells
AAACCTGCAGGCGATA-1    Monocytes     Monocytes
AAACCTGCATGAAGTA-1    Monocytes     Monocytes

> table(pred$labels)

     B-cells CD4+ T-cells CD8+ T-cells           DC  Eosinophils Erythrocytes 
         548          773         1275            1            1            5 
         HSC    Monocytes     NK cells 
          14         1126          251 
> 
```

Once we are done with creating an annotation DataFrame (pred), we are ready to plot it with `plotScoreHeatmap()`

```r
plotScoreHeatmap(pred)
```

![image21](https://user-images.githubusercontent.com/85447250/213538493-b8698ed1-b1bd-4ca5-bcd0-e1a2c8ad1da7.png)

Fig. Heatmap of the assignment score for each cell (column) and label (row).

**explanation for the plot above**

columns represents the cells from our test `SingleCellExperiment` object (sce.pbmc). Rows represents the labels (types of cells ) from the main annotation `SingleCellExperiment` object (ref here; if we remember it is the reference sample conataining all the annotations from Blueprint and ENCODE projects). Here we have 25 rows (cell types from ref) and we can tally this row with `factor(ref$label.main)`. So the reading for the heatmap goes like this; for every test cell (column) what are the scores for different labels (rows)?. Ideally, each cell in our test data should be annotated/assigned/recognized with just one of the labels (rows). For example, for first few columns if we look at the bottom left corner of the plot we do see a high score (bright yellow color) for B-cells (see rows). So, this bunch of cells has been annotated with B-cells (and luckey for us that we don't see yellow for any other rows. If that was the case we would be in trouble annotating these "first few columns" because in that case we would have an additional row/label to chose from and that is not always an easy task). We also see "Labels" to the right of scoring bar (a vertical bar with color gradient spanning higher to lower). This "Labels" indicates the recognized/annotated cells found in our test data set.

**end of explanation**

Another excercise that we can do is to compare assignments of cells with the clustering results to find out the identity of clusters.

```r
tab <- table(Assigned=pred$pruned.labels, Cluster=colLabels(sce.pbmc))

```

**explanation of "tab"**
 
 ```r
 > head(pred$pruned.labels, 25)
 [1] "Monocytes"    "Monocytes"    "CD4+ T-cells" "CD8+ T-cells" "Monocytes"   
 [6] "Monocytes"    "B-cells"      "CD8+ T-cells" "CD4+ T-cells" "CD4+ T-cells"
[11] "Monocytes"    "CD8+ T-cells" "CD8+ T-cells" "CD8+ T-cells" "Monocytes"   
[16] "CD8+ T-cells" "CD8+ T-cells" "CD4+ T-cells" "B-cells"      "CD8+ T-cells"
[21] "Monocytes"    "Monocytes"    "CD8+ T-cells" "NK cells"     "Monocytes" 

> head(colLabels(sce.pbmc), 25)
 [1] 2  2  9  3  6  1  4  9  9  3  6  3  9  11 6  9  3  3  4  9  2  10 9  8  2 
Levels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
```
So, the formation of the table "tab" goes like this. We do have two sets of data (`pred$pruned.labels` and `colLabels(sce.pbmc)`) of equal length (=`length(colnames(sce.pbmc))`). We look for "Monocytes" in first row of `head(pred$pruned.labels, 25)`. We find first and second indexes have "Monocytes" on them. Now we look at the first five indexes in `head(colLabels(sce.pbmc), 25)` we see first two indexes are labeled "2" (these two cells belong to cluster "2"). So what information do we get from here? it tells us that among the first five cells two are "Monocytes" and belong to cluster "2". We can extend this definition to find out what cluster contains which cell type in a tabular format (as seen below). 

```r
> tab
              Cluster
Assigned         1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
  B-cells        0   0   0 528   0   0   0   0   0  15   0   0   0   0   0   0
  CD4+ T-cells   1   0 262   0   1   0   0   0 442   0   0   0   0  58   0   2
  CD8+ T-cells   0   1 327   8 318   0   0   0 412   0 133   0   4  63   0   2
  DC             0   0   0   0   0   1   0   0   0   0   0   0   0   0   0   0
  Eosinophils    0   0   0   0   0   0   1   0   0   0   0   0   0   0   0   0
  Erythrocytes   0   0   1   0   0   0   4   0   0   0   0   0   0   0   0   0
  HSC            0   0   0   0   0   0   0   0   0  14   0   0   0   0   0   0
  Monocytes     55 729   0   0   0 125   0   0   0  16   0  69   0   0  84   0
  NK cells       0   0   0   2  32   0   0 166   0   0  16   0  26   0   0   1
  ```

```r
pheatmap(log2(tab+10), color=colorRampPalette(c("white", "blue"))(101))
```

![image22](https://user-images.githubusercontent.com/85447250/213925248-f4f3d95d-433c-44f0-9d36-56929ab27d46.png)


Fig. Heatmap of the distribution of cells across labels and clusters in the 10X PBMC dataset. Color scale is reported in the log10-number of cells for each cluster-label combination.


+ Using costom reference 

Up untill now we have been using an annotation object from ENCODE and Bluprint projects, but it is entirely possible to use own reference sample for cell type annotation. So, `SingleR` can be used with single-cell reference datasets that are curated and supplied by the user. This is most obviously useful when we have an existing dataset that was previously (manually) annotated and we want to use that knowledge to annotate a new dataset. So we will prepare a reference sample from muraro et al (2016).

```r
# Loading the data

sce.muraro <- MuraroPancreasData()

# Gene annotation 
edb <- AnnotationHub()[["AH73881"]]
gene.symb <- sub("__chr.*$", "", rownames(sce.muraro))

gene.ids <- mapIds(edb, keys = gene.symb, keytype = "SYMBOL",
                   column = "GENEID")

# Removing genes without ensemble IDs or Duplicated Ensemble IDs
keep <- !is.na(gene.ids) & !duplicated(gene.ids)
sce.muraro <- sce.muraro[keep, ]
rownames(sce.muraro) <- gene.ids[keep]

# Quality control
stats <- perCellQCMetrics(sce.muraro)
qc <- quickPerCellQC(stats, percent_subsets="altexps_ERCC_percent",
                     batch=sce.muraro$donor, subset=sce.muraro$donor!="D28")
sce.muraro <- sce.muraro[,!qc$discard]

# Normalization 
set.seed(1000)
clusters <- quickCluster(sce.muraro)
sce.muraro <- computeSumFactors(sce.muraro, clusters=clusters)
sce.muraro <- logNormCounts(sce.muraro)
```

```r
> sce.muraro
class: SingleCellExperiment 
dim: 16940 2299 
metadata(0):
assays(2): counts logcounts
rownames(16940): ENSG00000268895 ENSG00000121410 ... ENSG00000159840
  ENSG00000074755
rowData names(2): symbol chr
colnames(2299): D28-1_1 D28-1_2 ... D30-8_93 D30-8_94
colData names(4): label donor plate sizeFactor
reducedDimNames(0):
mainExpName: endogenous
altExpNames(1): ERCC
```

```r
sce.muraro <- sce.muraro[,!is.na(sce.muraro$label) & sce.muraro$label!="unclear"]

> table(sce.muraro$label)

     acinar       alpha        beta       delta        duct endothelial     epsilon 
        217         795         442         189         239          18           3 
mesenchymal          pp 
         80          96 
```

Now that we have got ourself a reference sample, we need to get a test data. We obtain out test data from Segerstolpe et al. (2016). 

```r
# getting test data
sce.seger <- SegerstolpePancreasData()

# Gene annotation
library(AnnotationHub)
edb <- AnnotationHub()[["AH73881"]]
symbols <- rowData(sce.seger)$symbol
ens.id <- mapIds(edb, keys=symbols, keytype="SYMBOL", column="GENEID")
ens.id <- ifelse(is.na(ens.id), symbols, ens.id)

# Removing duplicated rows.
keep <- !duplicated(ens.id)
sce.seger <- sce.seger[keep,]
rownames(sce.seger) <- ens.id[keep]

# Sample-annotation 
emtab.meta <- colData(sce.seger)[,c("cell type", "disease",
                                    "individual", "single cell well quality")]
colnames(emtab.meta) <- c("CellType", "Disease", "Donor", "Quality")
colData(sce.seger) <- emtab.meta

sce.seger$CellType <- gsub(" cell", "", sce.seger$CellType)
sce.seger$CellType <- paste0(
  toupper(substr(sce.seger$CellType, 1, 1)),
  substring(sce.seger$CellType, 2))
  
  
stats <- perCellQCMetrics(sce.seger)
qc <- quickPerCellQC(stats, percent_subsets="altexps_ERCC_percent",
                     batch=sce.seger$Donor,
                     subset=!sce.seger$Donor %in% c("HP1504901", "HP1509101"))

sce.seger <- sce.seger[,!(qc$discard | low.qual)]

# Normalization 
clusters <- quickCluster(sce.seger)
sce.seger <- computeSumFactors(sce.seger, clusters=clusters)
sce.seger <- logNormCounts(sce.seger) 
```

```r
# Converting to FPKM for a more like-for-like comparison to UMI counts

hs.db <- AnnotationHub()[["AH73881"]]

> hs.db
EnsDb for Ensembl:
|Backend: SQLite
|Db type: EnsDb
|Type of Gene ID: Ensembl Gene ID
|Supporting package: ensembldb
|Db created by: ensembldb package from Bioconductor
|script_version: 0.3.4
|Creation time: Sat Jul  6 01:28:30 2019
|ensembl_version: 97
|ensembl_host: localhost
|Organism: Homo sapiens
|taxonomy_id: 9606
|genome_build: GRCh38
|DBSCHEMAVERSION: 2.1
| No. of genes: 67667.
| No. of transcripts: 248916.
|Protein data available.


hs.exons <- exonsBy(hs.db, by="gene")
> hs.exons
GRangesList object of length 67667:
$ENSG00000000003
GRanges object with 20 ranges and 1 metadata column:
       seqnames              ranges strand |         exon_id
          <Rle>           <IRanges>  <Rle> |     <character>
   [1]        X 100639945-100639991      - | ENSE00001828996
   [2]        X 100636793-100637104      - | ENSE00001863395
   [3]        X 100636608-100636806      - | ENSE00001855382
   [4]        X 100636191-100636689      - | ENSE00001886883
   [5]        X 100635558-100635746      - | ENSE00003662440
   ...      ...                 ...    ... .             ...
  [16]        X 100632541-100632568      - | ENSE00001849132
  [17]        X 100632063-100632068      - | ENSE00003731560
  [18]        X 100630759-100630866      - | ENSE00000868868
  [19]        X 100628670-100629986      - | ENSE00001459322
  [20]        X 100627109-100629986      - | ENSE00003730948
  -------
  seqinfo: 424 sequences (1 circular) from GRCh38 genome

...
<67666 more elements>


hs.exons <- IRanges::reduce(hs.exons)
hs.exons
GRangesList object of length 67667:
$ENSG00000000003
GRanges object with 10 ranges and 0 metadata columns:
       seqnames              ranges strand
          <Rle>           <IRanges>  <Rle>
   [1]        X 100627109-100629986      -
   [2]        X 100630759-100630866      -
   [3]        X 100632063-100632068      -
   [4]        X 100632485-100632568      -
   [5]        X 100633405-100633539      -
   [6]        X 100633931-100634029      -
   [7]        X 100635178-100635252      -
   [8]        X 100635558-100635746      -
   [9]        X 100636191-100637104      -
  [10]        X 100639945-100639991      -
  -------
  seqinfo: 424 sequences (1 circular) from GRCh38 genome

$ENSG00000000005
GRanges object with 7 ranges and 0 metadata columns:
      seqnames              ranges strand
         <Rle>           <IRanges>  <Rle>
  [1]        X 100584936-100585066      +
  [2]        X 100585231-100585362      +
  [3]        X 100593624-100594035      +
  [4]        X 100594261-100594362      +
  [5]        X 100597504-100597657      +
  [6]        X 100599016-100599182      +
  [7]        X 100599508-100599885      +
  -------
  seqinfo: 424 sequences (1 circular) from GRCh38 genome

...
<67665 more elements>


hs.len <- sum(width(hs.exons))
head(hs.len)
ENSG00000000003 ENSG00000000005 ENSG00000000419 ENSG00000000457 ENSG00000000460 
           4535            1476            1207            6883            5970 
ENSG00000000938 
           3382 
> 

available <- intersect(rownames(sce.seger), names(hs.len))
fpkm.seger <- calculateFPKM(sce.seger[available,], hs.len[available])
```
**explanation**

`hs.db` is an EnsDb object for Homo sapiens from AnnotationHub(). It enlist all the transcripts and corresponding genes. It also provide a lot of metadata for all these transcripts (see columns(hs.db)). `exonBy()` will retrieve exons grouped by transcript or by gene (by genes here; exonBy(hs.db, by="gene")). This function returns a `GRangesList` object. `IRanges::reduce` function first orders the ranges in hs.exon from left to right, then merges the overlapping or adjacent ones. width(hs.exon) will give us the width for each IRange for each gene. sum(width(hs.exons)) will give the entire length (exon length)/span for each gene. 
**end of explanation**

```r
pred.seger <- SingleR(test=fpkm.seger, ref=sce.muraro, 
                      labels=sce.muraro$label, de.method="wilcox")

> table(pred.seger$labels)

     acinar       alpha        beta       delta        duct endothelial     epsilon 
        192         892         273         106         381          18           5 
mesenchymal          pp 
         52         171

> levels(factor(colData(sce.seger)$CellType))
 [1] "Acinar"                 "Alpha"                  "Beta"                  
 [4] "Co-expression"          "Delta"                  "Ductal"                
 [7] "Endothelial"            "Epsilon"                "Gamma"                 
[10] "MHC class II"           "NANA"                   "PSC"                   
[13] "Unclassified"           "Unclassified endocrine"

 > table(colData(sce.seger)$CellType)

                Acinar                  Alpha                   Beta 
                   185                    854                    246 
         Co-expression                  Delta                 Ductal 
                    39                    107                    378 
           Endothelial                Epsilon                  Gamma 
                    16                      5                    169 
          MHC class II                   NANA                    PSC 
                     4                     26                     53 
          Unclassified Unclassified endocrine 
                     2                      6 
> 

```
Now that we have run `SingleR` for our test sample (seger data) using `sce.muraro` as the reference sample, we can see different cell types found in seger data based on annotations from `sce.muraro` (see table(pred.seger$labels)). So these are the predicted labels (i.e., we have predicted through SingleR). At the same time, we also have user provided cell lables for every cells in `seger data` (see `levels(factor(colData(sce.seger)$CellType))` above). It will be interesting to see the comparison of these two annotations. Fortunately, we have a good match between these two which means we have been able to predict the labels as close and correctly as manually provided by the author (see fig. below).

```r
tab <- table(pred.seger$pruned.labels, sce.seger$CellType)
pheatmap(log2(tab+10), color=colorRampPalette(c("white", "blue"))(101))
```

![image23](https://user-images.githubusercontent.com/85447250/213925190-1ffb5743-f46a-4553-bcbd-8e09c536ef25.png)

Fig. Heatmap of the confusion matrix between the predicted labels (rows) and the independently defined labels (columns) in the Segerstolpe dataset. The color is proportinal to the log-transformed number of cells with a given combination of labels from each set.

### Assigning gene labels from gene sets

There is another way of annotating cells in our test data set. It explicitly identify sets of marker genes that are highly expressed in each individual cell. This does not require matching of individual cells to the expression values of the reference dataset, which is faster and more convenient when only the identities of the markers are available. We demonstrate this approach using neuronal cell type markers derived from the Zeisel et al. (2015).

```r
# loading the data
sce.zeisel <- ZeiselBrainData()
sce.zeisel <- aggregateAcrossFeatures(sce.zeisel, 
                          id=sub("_loc[0-9]+$", "", rownames(sce.zeisel)))

# gene annotation 
rowData(sce.zeisel)$Ensembl <- mapIds(org.Mm.eg.db, 
          keys=rownames(sce.zeisel), keytype="SYMBOL", column="ENSEMBL")
          
# Quality control
stats <- perCellQCMetrics(sce.zeisel, subsets=list(
  Mt=rowData(sce.zeisel)$featureType=="mito"))
qc <- quickPerCellQC(stats, percent_subsets=c("altexps_ERCC_percent", 
                                              "subsets_Mt_percent"))
sce.zeisel <- sce.zeisel[,!qc$discard]


# Normalization
set.seed(1000)
clusters <- quickCluster(sce.zeisel)
sce.zeisel <- computeSumFactors(sce.zeisel, cluster=clusters) 
sce.zeisel <- logNormCounts(sce.zeisel)

> levels(factor(sce.zeisel$level1class))
[1] "astrocytes_ependymal" "endothelial-mural"    "interneurons"        
[4] "microglia"            "oligodendrocytes"     "pyramidal CA1"       
[7] "pyramidal SS" 


# Step that explicitly identify sets of marker genes that are highly expressed in each individual cell

wilcox.z <- pairwiseWilcox(sce.zeisel, sce.zeisel$level1class, 
    lfc=1, direction="up")
    
> head(wilcox.z$statistics)
[[1]]
DataFrame with 19839 rows and 3 columns
                     AUC   p.value       FDR
               <numeric> <numeric> <numeric>
0610005C13Rik  0.0167598         1         1
0610007N19Rik  0.0864874         1         1
0610007P14Rik  0.2890363         1         1
0610009B22Rik  0.2358939         1         1
0610009D07Rik  0.3126047         1         1
...                  ...       ...       ...
Zyg11a        0.00558659         1         1
Zyg11b        0.21606145         1         1
Zyx           0.03365922         1         1
Zzef1         0.19804469         1         1
Zzz3          0.16941341         1         1

[[2]]
DataFrame with 19839 rows and 3 columns
                     AUC   p.value       FDR
               <numeric> <numeric> <numeric>
0610005C13Rik  0.0167598         1         1
0610007N19Rik  0.1094587         1         1
0610007P14Rik  0.2330380         1         1
0610009B22Rik  0.1490657         1         1
0610009D07Rik  0.1845117         1         1
...                  ...       ...       ...
Zyg11a        0.00558659         1         1
Zyg11b        0.10156039         1         1
Zyx           0.03563861         1         1
Zzef1         0.17913697         1         1
Zzz3          0.17056444         1         1

[[3]]
DataFrame with 19839 rows and 3 columns
                     AUC   p.value       FDR
               <numeric> <numeric> <numeric>
0610005C13Rik  0.0167598  1.000000         1
0610007N19Rik  0.1062169  1.000000         1
0610007P14Rik  0.2879960  1.000000         1
0610009B22Rik  0.2574846  1.000000         1
0610009D07Rik  0.3273886  0.999997         1
...                  ...       ...       ...
Zyg11a        0.00558659         1         1
Zyg11b        0.23334766         1         1
Zyx           0.03523850         1         1
Zzef1         0.20147543         1         1
Zzz3          0.16903022         1         1

[[4]]
DataFrame with 19839 rows and 3 columns
                     AUC   p.value       FDR
               <numeric> <numeric> <numeric>
0610005C13Rik  0.0167598         1         1
0610007N19Rik  0.1062968         1         1
0610007P14Rik  0.1277771         1         1
0610009B22Rik  0.1307364         1         1
0610009D07Rik  0.1964474         1         1
...                  ...       ...       ...
Zyg11a        0.00557937         1         1
Zyg11b        0.22596827         1         1
Zyx           0.03263176         1         1
Zzef1         0.19860552         1         1
Zzz3          0.14876647         1         1

[[5]]
DataFrame with 19839 rows and 3 columns
                     AUC   p.value       FDR
               <numeric> <numeric> <numeric>
0610005C13Rik  0.0167538         1         1
0610007N19Rik  0.1107610         1         1
0610007P14Rik  0.1951972         1         1
0610009B22Rik  0.1816238         1         1
0610009D07Rik  0.2493121         1         1
...                  ...       ...       ...
Zyg11a        0.00558659         1         1
Zyg11b        0.09257186         1         1
Zyx           0.03664042         1         1
Zzef1         0.16272588         1         1
Zzz3          0.15653179         1         1

[[6]]
DataFrame with 19839 rows and 3 columns
                     AUC   p.value       FDR
               <numeric> <numeric> <numeric>
0610005C13Rik  0.0167176         1         1
0610007N19Rik  0.1087204         1         1
0610007P14Rik  0.2177927         1         1
0610009B22Rik  0.1814024         1         1
0610009D07Rik  0.2296976         1         1
...                  ...       ...       ...
Zyg11a        0.00557252         1         1
Zyg11b        0.12014691         1         1
Zyx           0.03449052         1         1
Zzef1         0.17684308         1         1
Zzz3          0.16125128         1         1

> wilcox.z$pairs
DataFrame with 42 rows and 2 columns
                   first            second
             <character>       <character>
1   astrocytes_ependymal endothelial-mural
2   astrocytes_ependymal      interneurons
3   astrocytes_ependymal         microglia
4   astrocytes_ependymal  oligodendrocytes
5   astrocytes_ependymal     pyramidal CA1
...                  ...               ...
38          pyramidal SS endothelial-mural
39          pyramidal SS      interneurons
40          pyramidal SS         microglia
41          pyramidal SS  oligodendrocytes
42          pyramidal SS     pyramidal CA1

markers.z <- getTopMarkers(wilcox.z$statistics, wilcox.z$pairs,
    pairwise=FALSE, n=50)

> markers.z
List of length 7
names(7): astrocytes_ependymal endothelial-mural ... pyramidal CA1 pyramidal SS 

> names(markers.z)
[1] "astrocytes_ependymal" "endothelial-mural"    "interneurons"        
[4] "microglia"            "oligodendrocytes"     "pyramidal CA1"       
[7] "pyramidal SS"

> class(markers.z$astrocytes_ependymal)
[1] "character"

> lengths(markers.z)
astrocytes_ependymal    endothelial-mural         interneurons            microglia 
                  79                   83                  118                   69 
    oligodendrocytes        pyramidal CA1         pyramidal SS 
                  81                  125                  149 

```

**explanation**

`pairwiseWilcox(x, groups)`
x= a numeric matrix where each column corresponds to a cell and each row corresponds to an endogenous gene. or a SingleCellExperiment object representing such arrangments.
groups= A vector of length equal to ncol(x), specifying the group assignment for each cell. If x is a SingleCellExperiment, this is automatically derived from `colLabels`.

`pairwiseWilcox()` function performs Wilcoxon rank sum tests to identify differentially expressed genes (DEGs) between pairs of groups of cells (here, it will perform among groups "levels(factor(sce.zeisel$level1class))"). Since there are 7 groups so there will be a total of 42 comparisons (each group comparing with the rest of 6 groups for all groups i.e., 7x6=42). `pairwiseWilcox()` will return a list of 2 elements (containing element `statistics` and element `pairs`). Element `statistics` is list of tables (DataFrame) where each table contains the statistics (including the AUCs, p-values and false discovery rates) for all genes for a comparison between each pair of groups. The `pairs` element is a `DataFrame` with one row corresponding to each entry of `statistics`. This contains the fields `first` and `second`, specifying the two groups under comparison in the corresponding DataFrame in `statistics`. The effect size for each gene in each comparison is reported as the area under the curve (AUC). Consider the distribution of expression values for gene X within each of two groups A and B. The AUC (here we will assume effect size for genes in A) is the probability that a randomly selected cell in A has a greater expression of X than a randomly selected cell in B. (Ties are assumed to be randomly broken.) Concordance probabilities near 0 indicate that most observations in A are lower than most observations in B; conversely, probabilities near 1 indicate that most observations in A are higher than those in B. The Wilcoxon rank sum test effectively tests for significant deviations from an AUC of 0.5. So, in each DataFrame in `statistics`, the AUC represents the probability of sampling a value in the first group greater than a random value from the second group.  

To interpret the setting of `direction=`, consider the DataFrame for group X, in which we are comparing to another group Y. If direction="up", genes will only be significant in this DataFrame if they are upregulated in group X compared to Y. If direction="down", genes will only be significant if they are downregulated in group X compared to Y.

`lfc=` is a numeric scalar specifying the minimum log-fold change for one observation to be considered to be “greater” than another.


 function `getTopMarkers()` returns top markers for each pairwise comparison between clusters, or for each cluster. Usually, this function takes the form of `getTopMarkers(de.lists, pairs, pairwise=FALSE, n=50)` where 
 de.lists = 	A list-like object where each element is a DataFrame (`wilcox.z$statistics` here). Each element should represent the results of a pairwise comparison between two groups/clusters, in which each row should contain the statistics for a single gene/feature. Rows should be named by the feature name in the same order for all elements.
 
 pairs = A matrix or a DataFrame with two columns and number of rows equal to the length of `de.lists`. Each row should specify the pair of clusters being compared for the corresponding element of `de.lists`.
 
 	
n = Integer scalar specifying the number of markers to obtain from each pairwise comparison.

if pairwise=FALSE, `combineMarkers` is called on `de.lists` and `pairs` to obtain a per-cluster ranking of genes from all pairwise comparisons involving that cluster. if pairwise=FALSE, a List of character vectors is returned. Each character vector contains the marker genes that distinguish a cluster from all other clusters.

**end of explanation**

```r

all.sets <- lapply(names(markers.z), function(x) {
  GeneSet(markers.z[[x]], setName=x)        
}) 


details(all.sets[[1]])
setName: astrocytes_ependymal 
geneIds: Apoe, Clu, ..., Ncam1 (total: 79)
geneIdType: Null
collectionType: Null 
setIdentifier: compbio:133000:Sun Jan 22 12:17:32 2023:1
description: 
organism: 
pubMedIds: 
urls: 
contributor: 
setVersion: 0.0.1
creationDate:


all.sets <- GeneSetCollection(all.sets)

> all.sets
GeneSetCollection
  names: astrocytes_ependymal, endothelial-mural, ..., pyramidal SS (7 total)
  unique identifiers: Apoe, Clu, ..., Gabrb2 (555 total)
  types in collection:
    geneIdType: NullIdentifier (1 total)
    collectionType: NullCollection (1 total)
> 
```r
rankings <- AUCell_buildRankings(counts(sce.tasic),
    plotStats=FALSE, verbose=FALSE)
    
> rankings
Ranking for 24058 genes (rows) and 1809 cells (columns).

Top-left corner of the ranking:
               cells
genes           Calb2_tdTpositive_cell_1 Calb2_tdTpositive_cell_2
  0610005C13Rik                    14969                    13587
  0610007C21Rik                     2489                      503
  0610007L01Rik                     6538                     2509
  0610007N19Rik                    19319                    20713
  0610007P08Rik                    17152                    11199
  0610007P14Rik                    15805                     1487
               cells
genes           Calb2_tdTpositive_cell_3 Calb2_tdTpositive_cell_4
  0610005C13Rik                    11759                    16037
  0610007C21Rik                     1629                     1629
  0610007L01Rik                    12814                     7445
  0610007N19Rik                     7508                    22425
  0610007P08Rik                    14936                    17646
  0610007P14Rik                     3301                     1842
               cells
genes           Calb2_tdTpositive_cell_5
  0610005C13Rik                    18325
  0610007C21Rik                     2046
  0610007L01Rik                     6567
  0610007N19Rik                    22710
  0610007P08Rik                    12109
  0610007P14Rik                     1234
> 

cell.aucs <- AUCell_calcAUC(all.sets, rankings)

> cell.aucs
AUC for 7 gene sets (rows) and 1809 cells (columns).

Top-left corner of the AUC matrix:
                      cells
gene sets              Calb2_tdTpositive_cell_1 Calb2_tdTpositive_cell_2
  astrocytes_ependymal               0.13865276               0.13661743
  endothelial-mural                  0.04264310               0.04884635
  interneurons                       0.53060935               0.45383569
  microglia                          0.04845394               0.02682648
  oligodendrocytes                   0.13179577               0.12112934
  pyramidal CA1                      0.23176680               0.20625697
                      cells
gene sets              Calb2_tdTpositive_cell_3 Calb2_tdTpositive_cell_4
  astrocytes_ependymal               0.10873233               0.13216583
  endothelial-mural                  0.07268762               0.04993108
  interneurons                       0.34590730               0.51126651
  microglia                          0.03582241               0.05387632
  oligodendrocytes                   0.15672040               0.14808929
  pyramidal CA1                      0.32187260               0.25467138
                      cells
gene sets              Calb2_tdTpositive_cell_5
  astrocytes_ependymal               0.15128922
  endothelial-mural                  0.07161420
  interneurons                       0.49297711
  microglia                          0.06655747
  oligodendrocytes                   0.13857658
  pyramidal CA1                      0.20884775
> 


new.labels <- colnames(results)[max.col(results)]
tab <- table(new.labels, sce.tasic$broad_type)

> tab
                      
new.labels             Astrocyte Endothelial Cell GABA-ergic Neuron
  astrocytes_ependymal        43                2                 0
  endothelial-mural            0               27                 0
  interneurons                 0                0               759
  microglia                    0                0                 0
  oligodendrocytes             0                0                 1
  pyramidal SS                 0                0                 1
                      
new.labels             Glutamatergic Neuron Microglia Oligodendrocyte
  astrocytes_ependymal                    0         0               0
  endothelial-mural                       0         0               0
  interneurons                            2         0               0
  microglia                               0        22               0
  oligodendrocytes                        0         0              38
  pyramidal SS                          810         0               0
                      
new.labels             Oligodendrocyte Precursor Cell Unclassified
  astrocytes_ependymal                             20            4
  endothelial-mural                                 0            2
  interneurons                                      0           15
  microglia                                         0            1
  oligodendrocytes                                  2            0
  pyramidal SS                                      0           60
> 
```
**explanation**

The big story here is that we first take the zeisel `SingleCellExperiment` object (a brain cell data), which has a "cell label" for its each cell. next we identify the gene sets which define/identifies each cluster. Now we can use these gene sets to identify clusters from another brain `SingleCellExperiment` object tasic brain data (it is where library(AUCell) comes into play). `AUCell` will take gene sets generated from zeisel brain data and annotate cells in tasic brain data. Tasic brain data itself has some kind of cell annotation in `colData(sce.tasic)`. it will be intersting to observe how this newly generated annotation (with the help of AUCell) will fair against the annotation already available in `colData(sce.tasic)` 

`lapply` returns a list of the same length as X, each element of which is the result of applying FUN to the corresponding element of X.

A `GeneSet` contains a set of gene identifiers. Each gene set has a geneIdType, indicating how
the gene identifiers should be interpreted (e.g., as Entrez identifiers), and a collectionType, indi-
cating the origin of the gene set.

`AUCell_buildRankings()` does this; For each cell, the genes are ranked from highest to lowest value (see `rankings` above). 



Next,  

The AUC represents the proportion of expressed genes in the signature (gene set), and their relative expression value compared to the other genes within the cell. We can use this propperty to explore the population of cells that are present in the dataset according to the expression of the gene-set. In order to calculate the AUC, by default only the top 5% of the genes in the ranking are used (`AUCell_calcAUC()` will check whether the genes in the gene-set or signature are within the top 5%).

`AUCell_calcAUC()` determine whether the gene set is enriched at the top of the gene-ranking for each cell, AUCell uses the “Area Under the Curve” (AUC) of the recovery curve. The function `AUCell_calcAUC()` calculates this score, and returns a matrix with an AUC score for each gene-set in each cell (see `cell.aucs` above).

The AUC estimates the proportion of genes in the gene-set that are highly expressed in each cell. Cells expressing many genes from the gene-set will have higher AUC values than cells expressing fewer. So we assign cell type identity to each cell in the test dataset by taking the marker set with the top AUC as the label for that cell. However, determining whether the signature is active (or not) in a given cell is not always trivial. The AUC is not an absolute value, but it depends on the the cell type (i.e. cell size, amount of transcripts), the specific dataset (i.e. sensitivity of the measures) and the gene-set. It is often not straight forward to obtain a pruned signature of clear marker genes that are completely “on” in the cell type of interest and off" in every other cell. In addition, at single-cell level, most genes are not expressed or detected at a constant level.

the function `AUCell_exploreThresholds()` automatically plots all the histograms (see fig. below) and calculates several thresholds that could be used to consider a gene-set ‘active’ (returned in $aucThr). The ideal situation will be a bi-modal distribution, in which most cells in the dataset have a low “AUC” compared to a population of cells with a clearly higher value . The distributions are plotted as dotted lines over the histogram and the corresponding thresholds as vertical bars in the matching color. The "thicker vertical line" indicates the threshold selected by default ($aucThr$selected): the highest value to reduce the false positives. We also can see the thresholds calcuated for each gene set which are stored in the $aucThr slot. For example, the thresholds suggested for the `pyramidal CA1` gene-set is shown below. We also can see the warning masseges corresponding a histogram if there is any (see `warningMsg` below)  

Our new labels (`new.labels`) mostly agree with the original annotation from Tasic et al. (2016), which is encouraging (see `tab` above).

**end of explanation**


```r
cells_assignment <- AUCell_exploreThresholds(cell.aucs, 
                                             plotHist=TRUE, assign=TRUE)
par(mfrow=c(3,3))
AUCell_exploreThresholds(cell.aucs, 
                         plotHist=TRUE, assign=TRUE)
                         

warningMsg <- sapply(cells_assignment, function(x) x$aucThr$comment)
> warningMsg[which(warningMsg!="")]
                                                   interneurons 
                          " The right distribution is taller. " 
                                                  pyramidal CA1 
                          " The right distribution is taller. " 
                                                   pyramidal SS 
" The global distribution overlaps the partial distributions. "

> cells_assignment$`pyramidal CA1`$aucThr$thresholds
            threshold nCells
Global_k1   0.3323547    544
L_k2        0.1456062   1646
R_k3        0.2637205    997
minimumDens 0.1245364   1648

```

![image25](https://user-images.githubusercontent.com/85447250/214365689-b90abb57-e99e-4625-b988-1581c06fa1b4.png)

Fig. Distribution of AUCs in the Tasic brain dataset for each label in the Zeisel dataset. The blue curve represents the density estimate, the red curve represents a fitted two-component mixture of normals, the pink curve represents a fitted three-component mixture, and the grey curve represents a fitted normal distribution. Vertical lines represent threshold estimates corresponding to each estimate of the distribution.

**explanation**

So what to make of the figure above? It turns out that when you plot the the histogram of AUCs for a given gene-set, the resultant distribution in most cases is not a single peak distribution like a Gaussian, instead comprises many peaks (mostly $2$ or $3$). So what does that mean for our distribution? It means that there are $2$ or $3$ different kinds (when we say different kinds we don't mean different cell types in absolute sense of the words; it is just a mixture of $K$ diffrent population with different means; in modeling parlance these distributions are called Gausian Mixture Models or GMMs) of cells in that gene-set. That is why we have the red curve that represents a fitted two-component mixture of normals (i.e., $K=2$), the pink curve represents a fitted three-component mixture (i.e., $K=3$), the grey curve represents a fitted normal distribution (i.e., $K=1$). The vertical thick bar represent the number of cells and the AUC score to assign the label/cellType under consideration. And, the color of the bar represent the distribution selected (whether blue, red, pink or grey) for this threshold. For example, we look at the AUC histogram of "Oligodendrocytes". We see a pink thick vertical bar with value AUC=0.59 (34 cells). It means that when we plot the AUC histogram we would observe $3$ peaks. We don't see three distinct pink peaks in this particular example because of the scale of Y-axis. Means, we have three diffrent kinds of cells with three different means in our "Oligodendrocytes" population. From this distribution we have figured out that there are 34 cells which have an AUC score > $0.59$ and the vast majority of cells in this population have extremly low score for AUC corresponding the gene set "oligodendrocytes".

**end of explanation**

```r
# Loading the data

sce.mam <- BachMammaryData(samples="G_1")

# Gene annotation 
rownames(sce.mam) <- uniquifyFeatureNames(
  rowData(sce.mam)$Ensembl, rowData(sce.mam)$Symbol)
  
ens.mm.v97 <- AnnotationHub()[["AH73905"]]
rowData(sce.mam)$SEQNAME <- mapIds(ens.mm.v97, keys=rowData(sce.mam)$Ensembl,
    keytype="GENEID", column="SEQNAME")

# Quality control
is.mito <- rowData(sce.mam)$SEQNAME == "MT"
stats <- perCellQCMetrics(sce.mam, subsets=list(Mito=which(is.mito)))
qc <- quickPerCellQC(stats, percent_subsets="subsets_Mito_percent")
sce.mam <- sce.mam[,!qc$discard]

# Normalization

set.seed(101000110)
clusters <- quickCluster(sce.mam)
sce.mam <- computeSumFactors(sce.mam, clusters=clusters)
sce.mam <- logNormCounts(sce.mam)

# Variance modeling

set.seed(00010101)
dec.mam <- modelGeneVarByPoisson(sce.mam)
top.mam <- getTopHVGs(dec.mam, prop=0.1)

# Dimensionality reduction

set.seed(101010011)
sce.mam <- denoisePCA(sce.mam, technical=dec.mam, subset.row=top.mam)
sce.mam <- runTSNE(sce.mam, dimred="PCA")

# Clustering

snn.gr <- buildSNNGraph(sce.mam, use.dimred="PCA", k=25)
colLabels(sce.mam) <- factor(igraph::cluster_walktrap(snn.gr)$membership)

markers.mam <- scoreMarkers(sce.mam, lfc=1)

chosen <- "2"
cur.markers <- markers.mam[[chosen]]
is.de <- order(cur.markers$median.logFC.cohen, decreasing=TRUE)[1:100]
```

```r

> cur.markers[is.de,1:4]
DataFrame with 100 rows and 4 columns
        self.average other.average self.detected other.detected
           <numeric>     <numeric>     <numeric>      <numeric>
Csn2         8.91675       4.34354      1.000000       0.989293
Wfdc18       7.89056       3.42930      1.000000       0.836166
Csn1s1       7.83704       3.64794      1.000000       0.935088
Csn1s2a      9.21795       3.91963      1.000000       0.960138
Muc15        4.77990       1.57096      0.998748       0.446035
...              ...           ...           ...            ...
Ppp1cb       3.00484      1.921274      0.993742       0.820306
Cib1         2.38490      1.212979      0.942428       0.588033
Timm13       2.29062      1.542706      0.948686       0.749735
Prdx1        4.06969      3.364301      0.997497       0.975200
Pycard       1.88745      0.938662      0.881101       0.521319
```















                      














 
 
 
 




   







